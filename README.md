<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"></head><body class="c16"><p class="c9"><span class="c5">Name: Shaikh Ubaid</span></p><p class="c9"><span class="c5">Roll no: 180001050</span></p><p class="c9"><span class="c5">Date: 8 May, 2021</span></p><p class="c9"><span class="c5">Assignment no: 3</span></p><p class="c9"><span class="c5">Course: Computer Graphics</span></p><hr><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Q1: Boundary Fill</span></p><p class="c9"><span class="c5">Code:</span></p><a id="t.27af67d9adccac65deb51eef1bdbedc9cb263392"></a><a id="t.0"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c4">#include &lt;GL/glut.h&gt; /* for using glut library */</span><span class="c3"><br></span><span class="c4">#include &lt;cstdio&gt; &nbsp; &nbsp;/* for using printf and scanf */</span><span class="c3"><br></span><span class="c4">#include &lt;vector&gt; &nbsp; &nbsp;/* for using vector */</span><span class="c3"><br><br></span><span class="c4">#define WINDOW_WIDTH 1294</span><span class="c3"><br></span><span class="c4">#define WINDOW_HEIGHT 704</span><span class="c3"><br><br></span><span class="c0">// #define WINDOW_WIDTH 600</span><span class="c3"><br></span><span class="c0">// #define WINDOW_HEIGHT 400</span><span class="c3"><br><br></span><span class="c0">/* defining a structure for representing a point of the polygon */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Point</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;x, y;<br>} Point;<br><br></span><span class="c0">/* defining a structure for representing a colour of a point */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Colour</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">unsigned</span><span class="c3">&nbsp;</span><span class="c1">char</span><span class="c3">&nbsp;red, green, blue;<br>} Colour;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;no_of_polygon_points;<br></span><span class="c4">std</span><span class="c3">::</span><span class="c4">vector</span><span class="c3">&lt;Point&gt; polygon;<br>Point starting_point;<br>Colour cur_pixel, fill_colour, boundary_colour;<br><br></span><span class="c0">/* declaring the functions */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt;)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">boundaryFill</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">main</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;argc, </span><span class="c1">char</span><span class="c4">&nbsp;**argv)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;\tWELCOME TO POLYGON FILLING USING BOUNDARY FILL ALGORITHM\n&quot;</span><span class="c3">); </span><span class="c0">/* showing welcome message */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* prompting the user for input */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the number of points in the polygon: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d&quot;</span><span class="c3">, &amp;no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter %d points, each in a new line:\n&quot;</span><span class="c3">, no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;CAUTION: please ensure that you enter the points in clockwise or anticlockwise order\n&quot;</span><span class="c3">);<br> &nbsp; polygon.resize(no_of_polygon_points);<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; no_of_polygon_points; ++i)<br> &nbsp; {<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter coordinates of point %d (separated by a space): &quot;</span><span class="c3">, i + </span><span class="c4">1</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;polygon[i].x, &amp;polygon[i].y);<br> &nbsp; }<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the RGB values of colour for filling: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d %d&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.red, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.green, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.blue);<br><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the coordinates for starting point of Boundary Fill: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;starting_point.x, &amp;starting_point.y);<br><br> &nbsp; glutInit(&amp;argc, argv); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* initializing glut */</span><span class="c3"><br> &nbsp; glutInitDisplayMode(GLUT_SINGLE); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* use single color buffer and no depth buffer */</span><span class="c3"><br> &nbsp; glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* setting size of display area, in pixels. */</span><span class="c3"><br> &nbsp; glutInitWindowPosition(</span><span class="c4">0</span><span class="c3">, </span><span class="c4">0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* setting location of window in screen coordinates. */</span><span class="c3"><br> &nbsp; glutCreateWindow(</span><span class="c7">&quot;POLYGON FILLING USING BOUNDARY FILL ALGORITHM&quot;</span><span class="c3">); </span><span class="c0">/* giving name/title to window */</span><span class="c3"><br> &nbsp; init(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* setting our own OpenGL initialization */</span><span class="c3"><br> &nbsp; glutDisplayFunc(display); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* register display() function as the callback handler for window-paint event */</span><span class="c3"><br> &nbsp; glutMainLoop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* run the event loop! This function does not return */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* Program ends when user closes the window */</span><span class="c3"><br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;</span><span class="c4">0</span><span class="c3">;<br>}<br><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">&nbsp;</span><span class="c0">/* initialize OpenGL Graphics */</span><span class="c3"><br>{<br> &nbsp; glClearColor(</span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">1.0</span><span class="c3">); </span><span class="c0">/* set the &quot;clearing&quot; or background color as black and opaque*/</span><span class="c3"><br> &nbsp; glColor3ub(</span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* set white colour as drawing colour */</span><span class="c3"><br> &nbsp; </span><span class="c0">// glColor3i(255, 255, 255);</span><span class="c3"><br> &nbsp; glPointSize(</span><span class="c4">1.0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* each pixel is of size 1x1 */</span><span class="c3"><br> &nbsp; glMatrixMode(GL_PROJECTION);<br> &nbsp; glLoadIdentity();<br> &nbsp; gluOrtho2D(</span><span class="c4">0</span><span class="c3">, WINDOW_WIDTH, </span><span class="c4">0</span><span class="c3">, WINDOW_HEIGHT); </span><span class="c0">/* setting window dimension in X and Y directions */</span><span class="c3"><br>}<br><br></span><span class="c0">/* A function for drawing polygon. It expects given polygon points to be in clockwise or anticlockwise order */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt; polygon)</span><span class="c3"><br>{<br> &nbsp; glBegin(GL_LINE_LOOP); </span><span class="c0">/* using line loop so that the polygon is not already filled */</span><span class="c3"><br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;N = polygon.size();<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; N; ++i)<br> &nbsp; &nbsp; &nbsp; glVertex2i(polygon[i].x, polygon[i].y);<br> &nbsp; glEnd();<br>}<br><br></span><span class="c0">/* a function which returns true if given two colours are equal else it returns false */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;((c1-&gt;red == c2-&gt;red) &amp;&amp; (c1-&gt;green == c2-&gt;green) &amp;&amp; (c1-&gt;blue == c2-&gt;blue));<br>}<br><br></span><span class="c0">/* a function which returns true if given point is inside the window */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;!(x &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| y &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| x &gt; WINDOW_WIDTH || y &gt; WINDOW_HEIGHT);<br>}<br><br></span><span class="c0">/* a function to paint a pixel at given coordinates. It paints the pixel with colour value of fill_colour */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glRasterPos2i(x, y);<br> &nbsp; glDrawPixels(</span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;fill_colour);<br> &nbsp; glFlush();<br>}<br><br></span><span class="c0">/* a function to get the colour values at the given coordinates. It stores the colour values in cur_pixel */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glReadPixels(x, y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;cur_pixel);<br>}<br><br></span><span class="c0">/* my boundary fill function */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">boundaryFill</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">if</span><span class="c3">(!isValid(x, y))<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">return</span><span class="c3">;<br><br> &nbsp; getPixel(x, y);<br> &nbsp; </span><span class="c1">if</span><span class="c3">&nbsp;(isColourEqual(&amp;cur_pixel, &amp;fill_colour) || isColourEqual(&amp;cur_pixel, &amp;boundary_colour))<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">return</span><span class="c3">;<br><br> &nbsp; putPixel(x, y);<br> &nbsp; boundaryFill(x - </span><span class="c4">1</span><span class="c3">, y);<br> &nbsp; boundaryFill(x + </span><span class="c4">1</span><span class="c3">, y);<br> &nbsp; boundaryFill(x, y - </span><span class="c4">1</span><span class="c3">);<br> &nbsp; boundaryFill(x, y + </span><span class="c4">1</span><span class="c3">);<br>}<br><br></span><span class="c0">/* Our display function which runs when the window first appears and whenever there is a request to re-paint the window. */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3"><br>{<br> &nbsp; glClear(GL_COLOR_BUFFER_BIT); </span><span class="c0">/* clear the color buffer i.e. set background with the current &quot;clearing&quot; color */</span><span class="c3"><br><br> &nbsp; drawPolygon(polygon); </span><span class="c0">/* draw the polygon */</span><span class="c3"><br><br> &nbsp; glReadPixels(polygon[</span><span class="c4">0</span><span class="c3">].x, polygon[</span><span class="c4">0</span><span class="c3">].y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;boundary_colour); </span><span class="c0">/* get the colour of the boundary */</span><span class="c3"><br><br> &nbsp; </span><span class="c0">/* printing boundary colour on the console for user verification */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Boundary Colour is %d %d %d\n&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">)boundary_colour.red, (</span><span class="c1">int</span><span class="c3">)boundary_colour.green, (</span><span class="c1">int</span><span class="c3">)boundary_colour.blue);<br><br> &nbsp; boundaryFill(starting_point.x, starting_point.y); </span><span class="c0">/* fill the polygon */</span><span class="c3"><br><br> &nbsp; glFlush();<br>}</span></p></td></tr></tbody></table><p class="c9 c11"><span class="c5"></span></p><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Input:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Input:</span></p><a id="t.fbd08f7b8ea7180920c6b062290d5723d86f5797"></a><a id="t.1"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c14">23<br>300 330<br>330 310<br>304 279<br>343 298<br>354 266<br>362 300<br>423 276<br>463 309<br>413 299<br>423 330<br>439 316<br>435 353<br>394 320<br>405 372<br>373 337<br>390 403<br>373 384<br>337 397<br>355 380<br>319 382<br>354 348<br>288 374<br>333 331<br>0 255 0<br>350 310</span></p></td></tr></tbody></table><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 512.50px; height: 287.70px;"><img alt="" src="images/image6.png" style="width: 512.50px; height: 287.70px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c9"><span class="c5">Q2: Flood Fill</span></p><p class="c9"><span class="c5">Code:</span></p><a id="t.6fff0434657d64e38ce018bd69285d150074d84a"></a><a id="t.2"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c4">#include &lt;GL/glut.h&gt; /* for using glut library */</span><span class="c3"><br></span><span class="c4">#include &lt;cstdio&gt; &nbsp; &nbsp;/* for using printf and scanf */</span><span class="c3"><br></span><span class="c4">#include &lt;vector&gt; &nbsp; &nbsp;/* for using vector */</span><span class="c3"><br></span><span class="c4">#include &lt;queue&gt; &nbsp; &nbsp; /* for using queue */</span><span class="c3"><br><br></span><span class="c4">#define WINDOW_WIDTH 1294</span><span class="c3"><br></span><span class="c4">#define WINDOW_HEIGHT 704</span><span class="c3"><br><br></span><span class="c0">// #define WINDOW_WIDTH 600</span><span class="c3"><br></span><span class="c0">// #define WINDOW_HEIGHT 400</span><span class="c3"><br><br></span><span class="c0">/* defining a structure for representing a point of the polygon */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Point</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;x, y;<br>} Point;<br><br></span><span class="c0">/* defining a structure for representing colour of a point */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Colour</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">unsigned</span><span class="c3">&nbsp;</span><span class="c1">char</span><span class="c3">&nbsp;red, green, blue;<br>} Colour;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;no_of_polygon_points;<br></span><span class="c4">std</span><span class="c3">::</span><span class="c4">vector</span><span class="c3">&lt;Point&gt; polygon;<br>Point starting_point;<br>Colour cur_pixel, replacement_colour, target_colour;<br><br></span><span class="c0">/* declaring the functions */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt;)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">floodFill</span><span class="c4">()</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">main</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;argc, </span><span class="c1">char</span><span class="c4">&nbsp;**argv)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;\tWELCOME TO POLYGON FILLING USING FLOOD FILL ALGORITHM\n&quot;</span><span class="c3">); </span><span class="c0">/* showing welcome message */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* prompting the user for input */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the number of points in the polygon: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d&quot;</span><span class="c3">, &amp;no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter %d points, each in a new line:\n&quot;</span><span class="c3">, no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;CAUTION: please ensure that you enter the points in clockwise or anticlockwise order\n&quot;</span><span class="c3">);<br> &nbsp; polygon.resize(no_of_polygon_points);<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; no_of_polygon_points; ++i)<br> &nbsp; {<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter coordinates of point %d (separated by a space): &quot;</span><span class="c3">, i + </span><span class="c4">1</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;polygon[i].x, &amp;polygon[i].y);<br> &nbsp; }<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the RGB values of colour for filling: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d %d&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;replacement_colour.red, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;replacement_colour.green, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;replacement_colour.blue);<br><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the coordinates for starting point of Flood Fill: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;starting_point.x, &amp;starting_point.y);<br><br> &nbsp; glutInit(&amp;argc, argv); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* initializing glut */</span><span class="c3"><br> &nbsp; glutInitDisplayMode(GLUT_SINGLE); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* use single color buffer and no depth buffer */</span><span class="c3"><br> &nbsp; glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* setting size of display area, in pixels. */</span><span class="c3"><br> &nbsp; glutInitWindowPosition(</span><span class="c4">0</span><span class="c3">, </span><span class="c4">0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* setting location of window in screen coordinates. */</span><span class="c3"><br> &nbsp; glutCreateWindow(</span><span class="c7">&quot;POLYGON FILLING USING FLOOD FILL ALGORITHM&quot;</span><span class="c3">); </span><span class="c0">/* giving name/title to window */</span><span class="c3"><br> &nbsp; init(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* setting our own OpenGL initialization */</span><span class="c3"><br> &nbsp; glutDisplayFunc(display); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* register display() function as the callback handler for window-paint event */</span><span class="c3"><br> &nbsp; glutMainLoop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* run the event loop! This function does not return */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* Program ends when user closes the window */</span><span class="c3"><br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;</span><span class="c4">0</span><span class="c3">;<br>}<br><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">&nbsp;</span><span class="c0">/* initialize OpenGL Graphics */</span><span class="c3"><br>{<br> &nbsp; glClearColor(</span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">1.0</span><span class="c3">); </span><span class="c0">/* set the &quot;clearing&quot; or background color as black and opaque*/</span><span class="c3"><br> &nbsp; glColor3ub(</span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* set white colour as drawing colour */</span><span class="c3"><br> &nbsp; </span><span class="c0">// glColor3i(255, 255, 255);</span><span class="c3"><br> &nbsp; glPointSize(</span><span class="c4">1.0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* each pixel is of size 1x1 */</span><span class="c3"><br> &nbsp; glMatrixMode(GL_PROJECTION);<br> &nbsp; glLoadIdentity();<br> &nbsp; gluOrtho2D(</span><span class="c4">0</span><span class="c3">, WINDOW_WIDTH, </span><span class="c4">0</span><span class="c3">, WINDOW_HEIGHT); </span><span class="c0">/* setting window dimension in X and Y directions */</span><span class="c3"><br>}<br><br></span><span class="c0">/* A function for drawing polygon. It expects given polygon points to be in clockwise or anticlockwise order */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt; polygon)</span><span class="c3"><br>{<br> &nbsp; glBegin(GL_LINE_LOOP); </span><span class="c0">/* using line loop so that the polygon is not already filled */</span><span class="c3"><br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;N = polygon.size();<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; N; ++i)<br> &nbsp; &nbsp; &nbsp; glVertex2i(polygon[i].x, polygon[i].y);<br> &nbsp; glEnd();<br>}<br><br></span><span class="c0">/* a function which returns true if given two colours are equal else it returns false */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;((c1-&gt;red == c2-&gt;red) &amp;&amp; (c1-&gt;green == c2-&gt;green) &amp;&amp; (c1-&gt;blue == c2-&gt;blue));<br>}<br><br></span><span class="c0">/* a function which returns true if given point is inside the window */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;!(x &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| y &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| x &gt; WINDOW_WIDTH || y &gt; WINDOW_HEIGHT);<br>}<br><br></span><span class="c0">/* a function to paint a pixel at given coordinates. It paints the pixel with colour value of fill_colour */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glRasterPos2i(x, y);<br> &nbsp; glDrawPixels(</span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;replacement_colour);<br> &nbsp; glFlush();<br>}<br><br></span><span class="c0">/* a function to get the colour values at the given coordinates. It stores the colour values in cur_pixel */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glReadPixels(x, y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;cur_pixel);<br>}<br><br><br></span><span class="c0">/* my floodfill function */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">floodFill</span><span class="c4">()</span><span class="c3"><br>{<br> &nbsp; </span><span class="c4">std</span><span class="c3">::</span><span class="c4">queue</span><span class="c3">&lt;Point&gt; Q;<br> &nbsp; Q.push(starting_point);<br> &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(!Q.empty()) </span><span class="c0">/* while queue is not empty */</span><span class="c3"><br> &nbsp; {<br> &nbsp; &nbsp; &nbsp; Point cur = Q.front();<br> &nbsp; &nbsp; &nbsp; Q.pop();<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">if</span><span class="c3">&nbsp;(!isValid(cur.x, cur.y)) </span><span class="c0">/* if the current point is invalid, go for next iteration */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">continue</span><span class="c3">;<br><br> &nbsp; &nbsp; &nbsp; getPixel(cur.x, cur.y);<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">if</span><span class="c3">&nbsp;(isColourEqual(&amp;cur_pixel, &amp;target_colour))<br> &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putPixel(cur.x, cur.y);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.push({cur.x - </span><span class="c4">1</span><span class="c3">, cur.y});<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.push({cur.x + </span><span class="c4">1</span><span class="c3">, cur.y});<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.push({cur.x, cur.y - </span><span class="c4">1</span><span class="c3">});<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q.push({cur.x, cur.y + </span><span class="c4">1</span><span class="c3">});<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c0">/* Our display function which runs when the window first appears and whenever there is a request to re-paint the window. */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3"><br>{<br> &nbsp; glClear(GL_COLOR_BUFFER_BIT); </span><span class="c0">/* clear the color buffer i.e. set background with the current &quot;clearing&quot; color */</span><span class="c3"><br><br> &nbsp; drawPolygon(polygon); </span><span class="c0">/* draw the polygon */</span><span class="c3"><br><br> &nbsp; glReadPixels(starting_point.x, starting_point.y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;target_colour); </span><span class="c0">/* get the colour of the points to be painted */</span><span class="c3"><br> &nbsp;<br> &nbsp; </span><span class="c0">/* printing target colour on the console for user verification */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Target Colour is %d %d %d\n&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">)target_colour.red, (</span><span class="c1">int</span><span class="c3">)target_colour.green, (</span><span class="c1">int</span><span class="c3">)target_colour.blue);<br><br> &nbsp; floodFill(); </span><span class="c0">/* fill the polygon */</span><span class="c3"><br><br> &nbsp; glFlush();<br>}</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Input:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Input:</span></p><a id="t.fbd08f7b8ea7180920c6b062290d5723d86f5797"></a><a id="t.3"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c14">23<br>300 330<br>330 310<br>304 279<br>343 298<br>354 266<br>362 300<br>423 276<br>463 309<br>413 299<br>423 330<br>439 316<br>435 353<br>394 320<br>405 372<br>373 337<br>390 403<br>373 384<br>337 397<br>355 380<br>319 382<br>354 348<br>288 374<br>333 331<br>0 255 0<br>350 310</span></p></td></tr></tbody></table><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 475.56px; height: 267.50px;"><img alt="" src="images/image8.png" style="width: 475.56px; height: 267.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c9"><span class="c5">Q3: Scanline Seed Fill</span></p><p class="c9"><span class="c5">Code:</span></p><a id="t.4b1f83cd119559e21ac025a2212980f47c3835c2"></a><a id="t.4"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c4">#include &lt;GL/glut.h&gt; /* for using glut library */</span><span class="c3"><br></span><span class="c4">#include &lt;cstdio&gt; &nbsp; &nbsp;/* for using printf and scanf */</span><span class="c3"><br></span><span class="c4">#include &lt;vector&gt; &nbsp; &nbsp;/* for using vector */</span><span class="c3"><br></span><span class="c4">#include &lt;stack&gt; &nbsp; &nbsp; /* for using stack */</span><span class="c3"><br><br></span><span class="c4">#define WINDOW_WIDTH 1294</span><span class="c3"><br></span><span class="c4">#define WINDOW_HEIGHT 704</span><span class="c3"><br><br></span><span class="c0">// #define WINDOW_WIDTH 600</span><span class="c3"><br></span><span class="c0">// #define WINDOW_HEIGHT 400</span><span class="c3"><br><br></span><span class="c0">/* defining a structure for representing a point of the polygon */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Point</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;x, y;<br>} Point;<br><br></span><span class="c0">/* defining a structure for representing colour of a point */</span><span class="c3"><br></span><span class="c1">typedef</span><span class="c3">&nbsp;</span><span class="c1">struct</span><span class="c3">&nbsp;</span><span class="c2">Colour</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">unsigned</span><span class="c3">&nbsp;</span><span class="c1">char</span><span class="c3">&nbsp;red, green, blue;<br>} Colour;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;no_of_polygon_points;<br></span><span class="c4">std</span><span class="c3">::</span><span class="c4">vector</span><span class="c3">&lt;Point&gt; polygon;<br>Point starting_point;<br>Colour cur_pixel, fill_colour, boundary_colour;<br><br></span><span class="c0">/* declaring the functions */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt;)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isBoundary</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isFilled</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">scanlineSeedFill</span><span class="c4">()</span><span class="c3">;<br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">;<br><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">main</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;argc, </span><span class="c1">char</span><span class="c4">&nbsp;**argv)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;\tWELCOME TO POLYGON FILLING USING SCANLINE SEED FILL ALGORITHM\n&quot;</span><span class="c3">); </span><span class="c0">/* showing welcome message */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* prompting the user for input */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the number of points in the polygon: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d&quot;</span><span class="c3">, &amp;no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter %d points, each in a new line:\n&quot;</span><span class="c3">, no_of_polygon_points);<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;CAUTION: please ensure that you enter the points in clockwise or anticlockwise order\n&quot;</span><span class="c3">);<br> &nbsp; polygon.resize(no_of_polygon_points);<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; no_of_polygon_points; ++i)<br> &nbsp; {<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter coordinates of point %d (separated by a space): &quot;</span><span class="c3">, i + </span><span class="c4">1</span><span class="c3">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;polygon[i].x, &amp;polygon[i].y);<br> &nbsp; }<br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the RGB values of colour for filling: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d %d&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.red, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.green, (</span><span class="c1">int</span><span class="c3">&nbsp;*)&amp;fill_colour.blue);<br><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Enter the coordinates for starting point of Scanline Seed Fill: &quot;</span><span class="c3">);<br> &nbsp; </span><span class="c4">scanf</span><span class="c3">(</span><span class="c7">&quot;%d %d&quot;</span><span class="c3">, &amp;starting_point.x, &amp;starting_point.y);<br><br> &nbsp; glutInit(&amp;argc, argv); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* initializing glut */</span><span class="c3"><br> &nbsp; glutInitDisplayMode(GLUT_SINGLE); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* use single color buffer and no depth buffer */</span><span class="c3"><br> &nbsp; glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* setting size of display area, in pixels. */</span><span class="c3"><br> &nbsp; glutInitWindowPosition(</span><span class="c4">0</span><span class="c3">, </span><span class="c4">0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* setting location of window in screen coordinates. */</span><span class="c3"><br> &nbsp; glutCreateWindow(</span><span class="c7">&quot;POLYGON FILLING USING SCANLINE SEED FILL ALGORITHM&quot;</span><span class="c3">); </span><span class="c0">/* giving name/title to window */</span><span class="c3"><br> &nbsp; init(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* setting our own OpenGL initialization */</span><span class="c3"><br> &nbsp; glutDisplayFunc(display); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* register display() function as the callback handler for window-paint event */</span><span class="c3"><br> &nbsp; glutMainLoop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* run the event loop! This function does not return */</span><span class="c3"><br> &nbsp; </span><span class="c0">/* Program ends when user closes the window */</span><span class="c3"><br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;</span><span class="c4">0</span><span class="c3">;<br>}<br><br><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">init</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3">&nbsp;</span><span class="c0">/* initialize OpenGL Graphics */</span><span class="c3"><br>{<br> &nbsp; glClearColor(</span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">0.0</span><span class="c3">, </span><span class="c4">1.0</span><span class="c3">); </span><span class="c0">/* set the &quot;clearing&quot; or background color as black and opaque*/</span><span class="c3"><br> &nbsp; glColor3ub(</span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">, </span><span class="c4">255</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">/* set white colour as drawing colour */</span><span class="c3"><br> &nbsp; </span><span class="c0">// glColor3i(255, 255, 255);</span><span class="c3"><br> &nbsp; glPointSize(</span><span class="c4">1.0</span><span class="c3">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">/* each pixel is of size 1x1 */</span><span class="c3"><br> &nbsp; glMatrixMode(GL_PROJECTION);<br> &nbsp; glLoadIdentity();<br> &nbsp; gluOrtho2D(</span><span class="c4">0</span><span class="c3">, WINDOW_WIDTH, </span><span class="c4">0</span><span class="c3">, WINDOW_HEIGHT); </span><span class="c0">/* setting window dimension in X and Y directions */</span><span class="c3"><br>}<br><br><br></span><span class="c0">/* A function for drawing polygon. It expects given polygon points to be in clockwise or anticlockwise order */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">drawPolygon</span><span class="c4">(std::vector&lt;Point&gt; polygon)</span><span class="c3"><br>{<br> &nbsp; glBegin(GL_LINE_LOOP);<br> &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;N = polygon.size();<br> &nbsp; </span><span class="c1">for</span><span class="c3">&nbsp;(</span><span class="c1">int</span><span class="c3">&nbsp;i = </span><span class="c4">0</span><span class="c3">; i &lt; N; ++i)<br> &nbsp; &nbsp; &nbsp; glVertex2i(polygon[i].x, polygon[i].y);<br> &nbsp; glEnd();<br>}<br><br></span><span class="c0">/* a function which returns true if given two colours are equal else it returns false */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isColourEqual</span><span class="c4">(Colour *c1, Colour *c2)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;((c1-&gt;red == c2-&gt;red) &amp;&amp; (c1-&gt;green == c2-&gt;green) &amp;&amp; (c1-&gt;blue == c2-&gt;blue));<br>}<br><br></span><span class="c0">/* a function which returns true if given point is inside the window */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isValid</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;!(x &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| y &lt; </span><span class="c4">0</span><span class="c3">&nbsp;|| x &gt; WINDOW_WIDTH || y &gt; WINDOW_HEIGHT);<br>}<br><br></span><span class="c0">/* a function to paint a pixel at given coordinates. It paints the pixel with colour value of fill_colour */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">putPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glRasterPos2i(x, y);<br> &nbsp; glDrawPixels(</span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;fill_colour);<br> &nbsp; glFlush();<br>}<br><br></span><span class="c0">/* a function to get the colour values at the given coordinates. It stores the colour values in cur_pixel */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">getPixel</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; glReadPixels(x, y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;cur_pixel);<br>}<br><br></span><span class="c0">/* a function which returns true if the given coordinates are of a boundary point, else it returns false */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isBoundary</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; getPixel(x, y);<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;isColourEqual(&amp;cur_pixel, &amp;boundary_colour);<br>}<br><br></span><span class="c0">/* a function which returns true if the given coordinates are filled with fill_colour, else it returns false */</span><span class="c3"><br></span><span class="c1">int</span><span class="c3">&nbsp;</span><span class="c2">isFilled</span><span class="c4">(</span><span class="c1">int</span><span class="c4">&nbsp;x, </span><span class="c1">int</span><span class="c4">&nbsp;y)</span><span class="c3"><br>{<br> &nbsp; getPixel(x, y);<br> &nbsp; </span><span class="c1">return</span><span class="c3">&nbsp;isColourEqual(&amp;cur_pixel, &amp;fill_colour);<br>}<br><br></span><span class="c0">/* my scanline seed fill function */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">scanlineSeedFill</span><span class="c4">()</span><span class="c3"><br>{<br> &nbsp; </span><span class="c4">std</span><span class="c3">::</span><span class="c4">stack</span><span class="c3">&lt;Point&gt; S;<br> &nbsp; S.push(starting_point);<br> &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(!S.empty()) </span><span class="c0">/* while stack is not empty */</span><span class="c3"><br> &nbsp; {<br> &nbsp; &nbsp; &nbsp; Point cur = S.top();<br> &nbsp; &nbsp; &nbsp; S.pop();<br><br> &nbsp; &nbsp; &nbsp; putPixel(cur.x, cur.y);<br><br> &nbsp; &nbsp; &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;x, y, xleft, xright;<br> &nbsp; &nbsp; &nbsp; x = cur.x - </span><span class="c4">1</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(isValid(x, cur.y) &amp;&amp; !isBoundary(x, cur.y))<br> &nbsp; &nbsp; &nbsp; { </span><span class="c0">/* fill as left as possible */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putPixel(x, cur.y);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x--;<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; xleft = x + </span><span class="c4">1</span><span class="c3">; </span><span class="c0">/* extreme left end */</span><span class="c3"><br><br> &nbsp; &nbsp; &nbsp; x = cur.x + </span><span class="c4">1</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(isValid(x, cur.y) &amp;&amp; !isBoundary(x, cur.y))<br> &nbsp; &nbsp; &nbsp; { </span><span class="c0">/* fill as right as possible */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putPixel(x, cur.y);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; xright = x - </span><span class="c4">1</span><span class="c3">; </span><span class="c0">/* extreme right end */</span><span class="c3"><br><br><br> &nbsp; &nbsp; &nbsp; </span><span class="c0">/* find spans of unfilled points in the upper scanline */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; y = cur.y + </span><span class="c4">1</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; x = xleft;<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(isValid(x, y) &amp;&amp; x &lt;= xright)<br> &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(x &lt;= xright &amp;&amp; (isBoundary(x, y) || isFilled(x, y)))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;xprev = x;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(x &lt;= xright &amp;&amp; (!isBoundary(x, y) &amp;&amp; !isFilled(x, y)))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xprev = x;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">if</span><span class="c3">&nbsp;(xprev != x)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; S.push({xprev, y}); </span><span class="c0">/* push the extreme right end of the found span */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; </span><span class="c0">/* find spans of unfilled points in the lower scanline */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; y = cur.y - </span><span class="c4">1</span><span class="c3">;<br> &nbsp; &nbsp; &nbsp; x = xleft;<br> &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(isValid(x, y) &amp;&amp; x &lt;= xright)<br> &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(x &lt;= xright &amp;&amp; (isBoundary(x, y) || isFilled(x, y)))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">int</span><span class="c3">&nbsp;xprev = x;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">while</span><span class="c3">&nbsp;(x &lt;= xright &amp;&amp; (!isBoundary(x, y) &amp;&amp; !isFilled(x, y)))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xprev = x;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1">if</span><span class="c3">&nbsp;(xprev != x)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; S.push({xprev, y}); </span><span class="c0">/* push the extreme right end of the found span */</span><span class="c3"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c0">/* Our display function which runs when the window first appears and whenever there is a request to re-paint the window. */</span><span class="c3"><br></span><span class="c1">void</span><span class="c3">&nbsp;</span><span class="c2">display</span><span class="c4">(</span><span class="c1">void</span><span class="c4">)</span><span class="c3"><br>{<br> &nbsp; glClear(GL_COLOR_BUFFER_BIT); </span><span class="c0">/* clear the color buffer i.e. set background with the current &quot;clearing&quot; color */</span><span class="c3"><br><br> &nbsp; drawPolygon(polygon); </span><span class="c0">/* draw the polygon */</span><span class="c3"><br><br> &nbsp; glReadPixels(polygon[</span><span class="c4">0</span><span class="c3">].x, polygon[</span><span class="c4">0</span><span class="c3">].y, </span><span class="c4">1</span><span class="c3">, </span><span class="c4">1</span><span class="c3">, GL_RGB, GL_UNSIGNED_BYTE, &amp;boundary_colour); </span><span class="c0">/* get the colour of the boundary */</span><span class="c3"><br> &nbsp;<br> &nbsp; </span><span class="c0">/* printing boundary colour on the console for user verification */</span><span class="c3"><br> &nbsp; </span><span class="c4">printf</span><span class="c3">(</span><span class="c7">&quot;Boundary Colour is %d %d %d\n&quot;</span><span class="c3">, (</span><span class="c1">int</span><span class="c3">)boundary_colour.red, (</span><span class="c1">int</span><span class="c3">)boundary_colour.green, (</span><span class="c1">int</span><span class="c3">)boundary_colour.blue);<br><br> &nbsp; scanlineSeedFill(); </span><span class="c0">/* fill the polygon */</span><span class="c3"><br><br> &nbsp; glFlush();<br>}</span></p></td></tr></tbody></table><p class="c9 c11"><span class="c5"></span></p><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Input:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Input:</span></p><a id="t.fbd08f7b8ea7180920c6b062290d5723d86f5797"></a><a id="t.5"></a><table class="c6"><tbody><tr class="c13"><td class="c15" colspan="1" rowspan="1"><p class="c12"><span class="c14">23<br>300 330<br>330 310<br>304 279<br>343 298<br>354 266<br>362 300<br>423 276<br>463 309<br>413 299<br>423 330<br>439 316<br>435 353<br>394 320<br>405 372<br>373 337<br>390 403<br>373 384<br>337 397<br>355 380<br>319 382<br>354 348<br>288 374<br>333 331<br>0 255 0<br>350 310</span></p></td></tr></tbody></table><p class="c9 c11"><span class="c5"></span></p><p class="c9"><span class="c5">Test Case Output:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 517.50px; height: 291.09px;"><img alt="" src="images/image2.png" style="width: 517.50px; height: 291.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>